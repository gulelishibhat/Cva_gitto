#!/usr/bin/env python
# coding: utf-8

# In[3]:


import pandas as pd
import matplotlib.pyplot as plt
get_ipython().run_line_magic('matplotlib', 'inline')
import numpy as np
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from datetime import datetime as dt, timedelta
import seaborn as sns
from functools import reduce
from sklearn.metrics import r2_score


# In[4]:


#df = pd.read_csv('listings_sea.csv')


# In[5]:


df_c = pd.read_csv('calendar_sea.csv')# Read calendar data showing of seattle obtained from airbnb 


# In[6]:


df_c.columns# see the columns 


# In[7]:


df_c.head()


# In[8]:


df_c = df_c[df_c['available']=='t']#take only the listing_id which are available


# In[9]:


df_c.shape[0]# the number of rows after we remove not available rows


# In[10]:


df_c['date'] = pd.to_datetime(df_c['date'])#change the object into the date and split into year month and day


# In[11]:


df_c[['year','month','day']] = df_c.date.apply(lambda x: pd.Series(x.strftime("%Y,%m,%d").split(",")))


# In[13]:


df_c.head()


# In[14]:


len(df_c['listing_id'].unique())# numebr of unique listing_id


# In[15]:


df_list = pd.read_csv('listings_sea.csv')#read the listing file of seattle airbnb


# In[16]:


df_list.shape[0]


# In[17]:


df_list = df_list.rename(index=str, columns={"id": "listing_id"})# we want to merge the two files 
df = pd.merge(df_c, df_list, on = 'listing_id')


# In[18]:


columns_to_drop = ['available', 'host_id','host_location','host_acceptance_rate','host_neighbourhood',
                   'host_total_listings_count', 'weekly_price', 'monthly_price',
                   'security_deposit', 'cleaning_fee', 'calendar_updated',
                   'listing_url','last_scraped' ,'scrape_id', 'name', 'summary', 'space', 'description',
                   'experiences_offered', 'street', 'neighbourhood', 'neighbourhood_cleansed', 'zipcode',
                   'neighborhood_overview', 'notes', 'transit', 'thumbnail_url', 'medium_url', 'picture_url',
                   'xl_picture_url', 'host_url', 'host_name', 'host_about', 'host_thumbnail_url', 'host_picture_url',
                   'city', 'state', 'market', 'smart_location', 'country_code', 'country', 'latitude', 'longitude',
                   'is_location_exact', 'square_feet', 'has_availability', 'availability_30',
                   'availability_60', 'availability_90', 'availability_365', 'calendar_last_scraped',
                  'first_review', 'last_review', 'requires_license', 'license', 'jurisdiction_names', 'price_y',
                  'reviews_per_month']


# In[19]:


df_r = df.drop(columns = columns_to_drop)


# In[20]:


df_r_num = df_r.select_dtypes(include=['int','float'])#see the numerical columns


# In[21]:


df_r_cat = df_r.select_dtypes(include=['object'])# see the categorical columns


# In[22]:


df_r_num.columns


# In[23]:


df_r_cat.columns#we see the price_x, year , month , day in the categorical category


# In[24]:


df_r = df.dropna(subset=['price_x'])#remove any NaN from the column price_x


# In[25]:


df_r['price'] = df_r['price_x'].astype(str)# change the string type to numerical 
df_r['price'] = df_r['price'].str.replace("[$, ]", "").astype("float")
df_r = df_r.drop(columns = ['price_x'])


# In[26]:


df_r['month_'] = df_r['month'].astype(str)
df_r['month_'] = df_r['month_'].astype(int)
df_r = df_r.drop(columns = ['month'])


# In[27]:


df_r['year_'] = df_r['year'].astype(str)
df_r['year_'] = df_r['year_'].astype("int")
df_r = df_r.drop(columns = ['year'])


# In[28]:


mean_price = df_r.groupby('listing_id').mean()['price']# to get the mean value of price according to 

#plot
plt.figure(figsize=(15,5))
plt.hist(mean_price, bins=20)
plt.xticks(np.arange(0, 1700, step=100))
plt.ylabel('Number of listings')
plt.xlabel('Price, in $')
plt.title('number of listing vs price')


plt.savefig('Price_distribution.png')

plt.show()


# In[29]:


listings_by_month = pd.Series([12])# get the number of listing for differnt month
for i in range(1, 13):
    listings_by_month[i] = len(df_r[(df_r['month_'] == i) & (df_r['year_'] == 2016)]['listing_id'])
    
listings_by_month = listings_by_month.drop(0)


# In[30]:


plt.figure(figsize=(10,5))
plt.plot(listings_by_month)
plt.xticks(np.arange(1, 13, step=1))
plt.ylabel('Number of listings')
plt.xlabel('Month')
plt.title('Number of listings per month, 2016')

plt.savefig('number of available listings.png')

plt.show()


# In[31]:


host_response_time = df_r["host_response_time"].unique()
host_response_time


# In[32]:


df_r["host_response_time"].value_counts()


# In[33]:


sns.countplot(df_r['host_response_time'])
plt.savefig('host_response_time.png')


# In[34]:


df_r = df_r.dropna(subset=['host_response_rate', 'month_'])#drop any NaN for host_reponse_rate and month_


# In[35]:


df_r['host_response_rate'].value_counts()[:15].plot(kind='bar')
plt.title("Numeber of Listings vs Host Response rate")
plt.ylabel("Total number of listings")
plt.xlabel('host response rate')
plt.savefig('host_response_rate_counts.png')#see the distint rate percentage of host responses rate


# In[36]:


#get the number of listing with distinct host response time for different months
df_24 = df_r['month_'][df_r['host_response_time'] == 'within a day'].value_counts(normalize=True)
df_10 =df_r['month_'][df_r['host_response_time'] == 'within a few hours'].value_counts(normalize=True)
df_1 =df_r['month_'][df_r['host_response_time'] == 'within an hour'].value_counts(normalize=True)
df_72 =df_r['month_'][df_r['host_response_time'] == 'a few days or more'].value_counts(normalize=True)


# In[37]:


#changing the value counts into the data frame with given index
df_24 = df_24.reset_index()
df_24.columns=['months', 'a_day']
df_10 = df_10.reset_index()
df_10.columns=['months', 'few_hours']
df_1 = df_1.reset_index()
df_1.columns=['months', 'an_hour']
df_72 = df_72.reset_index()
df_72.columns=['months', 'few_days']


# In[38]:


#sort them by months 
df_24 = df_24.sort_values(by = 'months')
df_10 = df_10.sort_values(by = 'months')
df_1 = df_1.sort_values(by = 'months')
df_72 = df_72.sort_values(by = 'months')


# In[39]:


#merge them into the single dataframe
data_frames = [df_1, df_10, df_24, df_72]
df_merged = reduce(lambda  left,right: pd.merge(left,right,on=['months']), data_frames)


# In[40]:


df_merged_ = pd.melt(df_merged, id_vars=['months']).sort_values(['variable','value'])


# In[41]:


#plot multiple columns of host_response_time with months 
sns.barplot(x='months', y='value', data=df_merged_, hue = 'variable', orient ='v')
plt.xticks(rotation=90)
plt.ylabel('Normalize host response listing')
plt.title('Months vs host response ')
plt.savefig("host_response_time_vs_months.png")


# In[42]:


df.columns


# In[43]:


df_m = df[['accommodates','price_x','minimum_nights','bedrooms','host_acceptance_rate',
       'bathrooms','beds','host_listings_count','property_type','room_type','neighbourhood_group_cleansed','smart_location','maximum_nights','neighbourhood','host_response_rate', 'availability_30', 'availability_60', 'availability_90',
       'availability_365','host_is_superhost','cleaning_fee','security_deposit']]


# In[44]:


#Remove the string dollar from the price, cleaning , fee and security deposit and change into float
df_m['price'] = df_m['price_x'].astype(str)# change the string type to numerical 
df_m['price'] = df_m['price'].str.replace("[$, ]", "").astype("float")
df_m = df_m.drop(columns = ['price_x'])
df_m['cleaning_fee_'] = df_m['cleaning_fee'].astype(str)# change the string type to numerical 
df_m['cleaning_fee_'] = df_m['cleaning_fee_'].str.replace("[$, ]", "").astype("float")
df_m = df_m.drop(columns = ['cleaning_fee'])
df_m['security_deposit_'] = df_m['security_deposit'].astype(str)# change the string type to numerical 
df_m['security_deposit_'] = df_m['security_deposit_'].str.replace("[$, ]", "").astype("float")
df_m = df_m.drop(columns = ['security_deposit'])


# In[45]:


#Remove % and change into the float
df_m['host_response_rates'] = df_m['host_response_rate'].astype(str)# change the string type to numerical 
df_m['host_response_rates'] = df_m['host_response_rates'].str.rstrip('%').astype('float') / 100.0
df_m = df_m.drop(columns = ['host_response_rate'])


# In[46]:


df_m['host_acceptance_rates'] = df_m['host_acceptance_rate'].astype(str)# change the string type to numerical 
df_m['host_acceptance_rates'] = df_m['host_acceptance_rates'].str.rstrip('%').astype('float') / 100.0
df_m = df_m.drop(columns = ['host_acceptance_rate'])


# In[47]:


#fill the NaN with mean
df_m['cleaning_fee_'] = df_m['cleaning_fee_'].fillna(df_m['cleaning_fee_'].mean())
df_m['security_deposit_'] = df_m['security_deposit_'].fillna(df_m['security_deposit_'].mean())
df_m['host_response_rates']=df_m['host_response_rates'].fillna(df_m['host_response_rates'].mean())
df_m['host_acceptance_rates']=df_m['host_acceptance_rates'].fillna(df_m['host_acceptance_rates'].mean())


# In[48]:


#fill the NaN with mode.
df_m['bedrooms']=df_m['bedrooms'].fillna(df_m['bedrooms'].mode()[0])
df_m['bathrooms']=df_m['bathrooms'].fillna(df_m['bathrooms'].mode()[0])
df_m['beds']=df_m['beds'].fillna(df_m['beds'].mode()[0])
#df_m['host_response_time']=df_m['host_response_time'].fillna(df_m['host_response_time'].mode()[0])
df_m['neighbourhood']=df_m['neighbourhood'].fillna(df_m['neighbourhood'].mode()[0])
df_m['property_type']=df_m['property_type'].fillna(df_m['property_type'].mode()[0])
df_m['host_listings_count']=df_m['host_listings_count'].fillna(df_m['host_listings_count'].mode()[0])
df_m['host_is_superhost']=df_m['host_is_superhost'].fillna(df_m['host_is_superhost'].mode()[0])
#df_m['host_since']=df_m['host_since'].fillna(df_m['host_since'].mode()[0])


# In[49]:


#check the null
np.sum(df_m.isnull())


# In[50]:


#see the dtypes
df_m.dtypes


# In[51]:


df_m.dtypes


# In[52]:


#seperate the numerical and categorical columns
df_m_cat = df_m.select_dtypes(include='object')
df_m_num = df_m.select_dtypes(include=['int', 'float'])


# In[53]:


df_m_cat.columns


# In[54]:


df_m_num.columns


# In[55]:


df_m.head()


# In[56]:


df_m.corr(method='pearson')


# In[57]:


#make dummy to the objects of  categorical columns 
df_mo = pd.get_dummies(df_m, columns =df_m_cat.columns)


# In[58]:


df_mo.columns


# In[72]:


#Define x and y
y = df_mo['host_response_rates']
x= df_mo.drop(columns=['host_response_rates'], axis =1)


# In[78]:


#Use the linear model
X_train, X_test, y_train, y_test = train_test_split(x, y, test_size = 0.15, random_state=42)
slr = LinearRegression()
slr.fit(X_train, y_train)
y_train_pred = slr.predict(X_train)
y_test_pred = slr.predict(X_test)
rsquared_score = r2_score(y_test, y_test_pred)
length_y_test = len(y_test)


# In[79]:


rsquared_score


# In[80]:


length_y_test


# In[81]:


plt.scatter(y_train_pred,  y_train_pred - y_train,
            c='blue', marker='o', label='Training data')
plt.scatter(y_test_pred,  y_test_pred - y_test,
            c='lightgreen', marker='s', label='Test data')
plt.xlabel('Predicted values')
plt.ylabel('Residuals')
plt.legend(loc='upper left')
plt.savefig('ResidualvsPredicted.png')
plt.show()


# In[ ]:




